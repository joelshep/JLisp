package org.ulithi.jlisp.parser;

import org.ulithi.jlisp.commons.StringUtils;
import org.ulithi.jlisp.mem.Cell;
import org.ulithi.jlisp.mem.PTree;

import java.util.ArrayList;
import java.util.List;

import static org.ulithi.jlisp.parser.Symbols.*;

/**
 * Transforms an ordered list of tokens generated by the {@link org.ulithi.jlisp.lexer.Lexer} into
 * a {@link org.ulithi.jlisp.mem.PTree}, which can then be evaluated as a LISP expression.
 */
public class Parser2 {
    /**
     * An ordered list of parse trees representing individual LISP statements, ready for evaluation.
     */
    private final List<PTree> statements = new ArrayList<>();

    /**
     * Parses and construct parse trees for the LISP statements in the given list of tokens. Parsed
     * statements are appended to this parser's statements list.
     *
     * @param tokens An ordered list of LISP language tokens produced by lexical analysis of one
     *               or more LISP statements.
     */
    public void parse(final List<String> tokens) {
        int i = 0; // Current index in the tokens list.
        int s = 0; // Starting index of the next statement to parse.
        int e = 0; // Index of the last token in the statement to be parsed.

        while ( i >= 0 && i < tokens.size() ) {
            // Determine the start of the next statement.
            s = StringUtils.indexOf(tokens, i, LPAREN);

            if ( s == i ) {
                // The next statement starts at the current index, i.
                e = endOfExpression(new ArrayList<>(tokens.subList(i, tokens.size()))) + i;
            } else if ( s > i ) {
                // The next statement begins after some number of tokens.
                e = s - 1;
            } else {
                // We've already seen the last list start. Parse any remaining tokens.
                e = tokens.size() - 1;
            }

            // "sexpr" is actual a list of tokens representing the tokenized expression in
            // dotted-pair form. e.g., "( PLUS 3 2 )" becomes "( PLUS . (3 . (2 . NIL) ) )".
            // Transform the expression starting at i and ending at e to dotted-pair tokenization.
            final List<String> sexpr = toDottedPair(new ArrayList<>(tokens.subList(i, e+1)));

            // Transform the dotted pair tokenization to the final in-memory tree representation.
            //statements.add(new PTree(sexpr));

            i = e + 1;
        }
    }

    /**
     * Transforms the given list of LISP program tokens to list of tokens representing the expression
     * as a dotted-pair expression.
     *
     * @param tokens An ordered list of tokens representing a parsed LISP expression.
     * @return The expression as a dotted-pair expression.
     */
    private static List<String> toDottedPair(final List<String> tokens) {
        List<String> dpTokens = new ArrayList<>();
        List<String> temp;
        int nextInnerToken;

        // If the first token is an atom (not a list-start), then add any successive tokens
        // and lists to the dotted pair expression and return it.
        if (!tokens.get(0).equals(LPAREN)) {
            if (tokens.indexOf(LPAREN) > 0) {
                dpTokens.addAll(tokens.subList(0, tokens.indexOf(LPAREN)));
                dpTokens.addAll(toDottedPair(tokens.subList(tokens.indexOf(LPAREN), tokens.size())));
            } else {
                dpTokens = tokens;
            }

            return dpTokens;
        }

        // We have a list: find the end of it.
        final int closeParen = endOfExpression(tokens);

        // If the end of the list is the next token, we have an empty list. Transform
        // to NIL and return.
        if (closeParen == 1) /*closeParen <= 1)*/ {
            dpTokens.add(NIL);
            return dpTokens;
        }

        // We must have a non-empty list. If it contains a single atom, return an atom-dot-NIL
        // set of tokens and return.
        dpTokens.add(LPAREN);

        if (closeParen == 2) {
            // The statement is in the form ( a )
            //Cell cell = new Cell(tokens.get(1)); // TODO - This is Equivalent
            dpTokens.add(tokens.get(1));
            dpTokens.add(DOT);
            dpTokens.add(NIL);
            dpTokens.add(RPAREN);
            return dpTokens;
        }

        // We have a list with more than one atom. Handle this recursively.

        // Is the first one a nested expression?
        if (tokens.get(1).equals(LPAREN)) {
            nextInnerToken = endOfExpression(tokens.subList(1, closeParen)) + 2;
        } else {
            nextInnerToken = 2;
        }

        if (tokens.get(nextInnerToken).equals(DOT)) {
            // Since it is in the form of ( [stuff] . [stuff] ), we pass [stuff] to be converted
            dpTokens.addAll(toDottedPair(tokens.subList(1, nextInnerToken)));
            dpTokens.add(DOT);
            dpTokens.addAll(toDottedPair(tokens.subList(nextInnerToken+1, closeParen)));
        } else {
            // The expression must be a list because it is not in dot-notation
            dpTokens.addAll(toDottedPair(tokens.subList(1, nextInnerToken)));
            dpTokens.add(DOT);
            temp = new ArrayList<>();
            temp.add(LPAREN);
            temp.addAll(tokens.subList(nextInnerToken, closeParen));
            temp.add(RPAREN);
            dpTokens.addAll(toDottedPair(temp));
        }

        dpTokens.add(RPAREN);

        return dpTokens;
    }

    /**
     * This finds the closing parenthesis of a given Lisp segment
     *
     * @param tokens The tokens (in dot-notation) of a segment of Lisp code
     * @return the index of the closing parenthesis
     *
     * @throws IllegalArgumentException If the vector is not a parenthetical expression
     * @throws ArrayIndexOutOfBoundsException If the statement does not have a closing parenthesis
     *
     */
    private static int endOfExpression(final List<String> tokens) throws IllegalArgumentException, ArrayIndexOutOfBoundsException {

        if ( ! tokens.get(0).matches("[(]") ){
            throw new IllegalArgumentException("ERROR: Tried to find the end of an expression that did not begin with '('.");
        }

        int openPairs = 1;
        int end = 1;
        while (openPairs > 0) {
            if (end >= tokens.size()) {
                throw new ArrayIndexOutOfBoundsException("Error! Unbalanced parentheses.");
            }
            if (tokens.get(end).matches("[)]")) {
                openPairs--;
            } else if (tokens.get(end).matches("[(]")) {
                openPairs++;
            }
            if (openPairs == 0) {
                break;
            } else {
                end++;
            }
        }
        return end;
    }
}
