package org.ulithi.jlisp.parser;

import org.ulithi.jlisp.commons.CollectionUtils;
import org.ulithi.jlisp.exception.JLispRuntimeException;
import org.ulithi.jlisp.exception.ParseException;
import org.ulithi.jlisp.mem.Cell;
import org.ulithi.jlisp.mem.PTree;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import static org.ulithi.jlisp.parser.Grammar.*;

/**
 * Transforms an ordered list of tokens generated by the {@link org.ulithi.jlisp.lexer.Lexer} into
 * a {@link org.ulithi.jlisp.mem.PTree}, which can then be evaluated as a LISP expression.
 */
public class Parser {
    /**
     * An ordered list of parse trees representing individual LISP expressions, ready for evaluation.
     */
    private final List<PTree> expressions = new ArrayList<>();

    /**
     * Parses and construct parse trees for the LISP statements in the given list of tokens. Parsed
     * expressions are appended to this parser's expressions list.
     *
     * @param tokens An ordered list of LISP language tokens produced by lexical analysis of one
     *               or more LISP expressions.
     */
    public PTree parse(final List<String> tokens) {
        if (CollectionUtils.isEmpty(tokens)) {
            throw new ParseException("Can't parse empty expression");
        }

        if (tokens.size() == 1) {
            return new PTree(Cell.create(tokens.get(0)));
        }

        return parseList(tokens);
    }

    private PTree parseList(final List<String> tokens) {
        if (tokens == null) {
            throw new JLispRuntimeException("Unexpected null token list");
        }

        // The full parsed expression.
        PTree pTree = null;

        Stack<PTree> stack = new Stack<>();
        PTree current = new PTree();
        boolean outer = true;

        for (final String token: tokens) {
            if (token.equals(LPAREN)) {
                if (!outer) {
                    stack.push(current);
                    current = new PTree();
                }
                outer = false;
            } else if (token.equals(RPAREN)) {
                if (stack.empty()) {
                    pTree = current;
                } else {
                    PTree next = current;
                    current = stack.pop();
                    current.addList(next.root());
                }
            } else {
                current.add(Cell.create(token));
            }
        }

        return pTree;
    }

    /**
     * This finds the closing parenthesis of a given Lisp segment
     *
     * @param tokens The tokens (in dot-notation) of a segment of Lisp code
     * @return the index of the closing parenthesis
     *
     * @throws IllegalArgumentException If the vector is not a parenthetical expression
     * @throws ArrayIndexOutOfBoundsException If the statement does not have a closing parenthesis
     *
     */
    private static int endOfExpression(final List<String> tokens) throws IllegalArgumentException, ArrayIndexOutOfBoundsException {

        if ( ! tokens.get(0).matches("[(]") ){
            throw new IllegalArgumentException("ERROR: Tried to find the end of an expression that did not begin with '('.");
        }

        int openPairs = 1;
        int end = 1;
        while (openPairs > 0) {
            if (end >= tokens.size()) {
                throw new ArrayIndexOutOfBoundsException("Error! Unbalanced parentheses.");
            }
            if (tokens.get(end).matches("[)]")) {
                openPairs--;
            } else if (tokens.get(end).matches("[(]")) {
                openPairs++;
            }
            if (openPairs == 0) {
                break;
            } else {
                end++;
            }
        }
        return end;
    }
}
