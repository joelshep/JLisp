package org.ulithi.jlisp.parser;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * The {@link Lexer} forms LISP language tokens from an {@link InputStream} or a {@link String} of
 * characters representing a LISP program or expression to be evaluated.
 * <p>
 * Aside from basic tokenization, the {@code Lexer} also handles expansion of the single-quote ( ' )
 * shorthand for the QUOTE function: e.g., transforms 'A in the input to "(", "QUOTE", "A", ")" in
 * the generated list of tokens.
 * <p>
 * I originally tried to do this in the {@link Parser}, but that proved more challenging since it
 * involves some amount of look-ahead to determine what is being quoted. It's easier to do hear
 * than to deal with the complexity of the {@code PTree} being generated by the parser.
 */
public class Lexer {
    /** The ordered list of tokens produced by lexical analysis. */
    private final List<String> tokens;

    /**
     * Constructor which can take a stream as input. It reads the stream and tokenizes
     * it appropriately.
     *
     * @param stream An input stream
     */
    public Lexer(final InputStream stream) throws IOException {
        final byte[] bytes = new byte[1024];
        final StringBuilder text = new StringBuilder();

        while (stream.available() > 0 && stream.read(bytes, 0, 1024) > 0) {
            text.append(new String(bytes).trim().toUpperCase());
            Arrays.fill(bytes, (byte) 0);
        }

        tokens = tokenize(text.toString());
    }

    /**
     * Constructs a {@link Lexer} to produce tokens from a given input string.
     * @param s A string -- presumably representing a LISP program or expression -- to be tokenized.
     */
    public Lexer(final String s) {
        tokens = tokenize(s);
    }

    /**
     * Returns the tokens formed from the stream or string by this {@link Lexer}.
     *
     * @return An ordered list of tokens.
     */
    public List<String> getTokens() {
        return Collections.unmodifiableList(tokens);
    }

    /**
     * Transforms a string into an ordered list of Lisp language tokens.

     * @param s A string representing (presumably) a Lisp language statement or program.
     * @return An ordered list of Lisp language tokens extracted from the given string.
     */
    private static List<String> tokenize(final String s) {
        if (s.length() == 1) { return Collections.singletonList(s); }

        final List<String> tokens = new ArrayList<>();

        int i = 0;
        boolean inQuote = false;     // Are we processing quoted (') input?
        int depth = 0;               // Parenthesis depth of quoted (') input.
        boolean expectAtom = false;  // Whether we expect the quoted (') input to be an atom.

        while (i < s.length()) {
            int j = i + 1;
            final String ch = s.substring(i, j);

            if (ch.matches(Grammar.QUOTE) && !inQuote) {
                tokens.add(Grammar.LPAREN);
                tokens.add("QUOTE");
                inQuote = true;
                expectAtom = true;
            } else if (ch.matches(Grammar.LETTER) || ch.matches(Grammar.NUMERIC_LITERAL_START)) {
                while (j < s.length() &&
                        (s.substring(i, j + 1).matches(Grammar.ALPHA_LITERAL) || s.substring(i, j + 1).matches(Grammar.NUMERIC_LITERAL))) {
                    j++;
                }
                tokens.add(s.substring(i, j));

                if (expectAtom) {
                    tokens.add(Grammar.RPAREN);
                    inQuote = false;
                    expectAtom = false;
                }
            } else if (ch.equals(Grammar.LPAREN)) {
                expectAtom = false;
                if (inQuote) { depth++; }
                tokens.add(ch);
            } else if (ch.equals(Grammar.RPAREN)) {
                if (inQuote) {
                    depth--;
                    if (depth == 0) {
                        tokens.add(Grammar.RPAREN);
                        inQuote = false;
                    }
                }
                tokens.add(ch);
            } else if (ch.matches(Grammar.SYMBOL)) {
                tokens.add(ch);
            }
            i = j;
        }
        return tokens;
    }
}
